Hands on #1: Save the previous world as collision_avoidance.wbt. 
Create a new C (or any other language) controller called epuck_avoid_collision 
(for C++ and Java call it EPuckAvoidCollision instead) from the File / New / New Robot Controller...
 menu item. Modify the controller field of the E-puck node in order to associate it to the new controller.

 Hands on #2: At the beginning of the controller file, add the import directives corresponding to the Robot, 
 the DistanceSensor and the Motor nodes in order to be able to use the corresponding API:

from controller import Robot, DistanceSensor, Motor
Just after the import statements define a variable that defines the duration of each physics step. 
This macro will be used as argument to the Robot::step function, and it will also be used to enable the devices. 
This duration is specified in milliseconds and it must be a multiple of the value in the basicTimeStep field of 
the WorldInfo node.

TIME_STEP = 64
The main function is where the controller program starts execution. 
The arguments passed to the main function are given by the controllerArgs field of the Robot node. 
The Webots API has to be initialized using the wb_robot_init function and it has to be cleaned up using 
the wb_robot_cleanup function.

Hands on #3: In Python there is no main function, the program starts it's execution from the start of the file:

# create the Robot instance.
robot = Robot()
# initialize devices
# feedback loop: step simulation until receiving an exit event
while robot.step(TIME_STEP) != -1:
    # read sensors outputs
    # process behavior
    # write actuators inputs
A robot device is referenced by a WbDeviceTag. The WbDeviceTag is retrieved by the wb_robot_get_device function. 
Then it is used as first argument in every function call concerning this device. 
A sensor such as the DistanceSensor has to be enabled before use. 
The second argument of the enable function defines at which rate the sensor will be refreshed.